// Security and encryption configuration
/// Defines the database schema with enhanced security features and documentation

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// User-related enums and types
enum Role {
  USER
  ADMIN
  SUPER_ADMIN
}

enum NotificationType {
  EMAIL
  PUSH
  SMS
}

enum RecurringType {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

enum PaymentMethodEnum {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  BANK_TRANSFER
  CHECK
  CRYPTO
  OTHER
}

enum DataEncryptionStatus {
  ENCRYPTED
  PLAINTEXT
  REDACTED
}

/// User model with enhanced security and privacy features
/// @index([email, isDeleted]) - Optimizes user lookup by email while respecting soft delete status
model User {
  id              String         @id @default(cuid())
  email           String         @unique
  role            Role          @default(USER)
  isActive        Boolean       @default(true)
  emailVerified   DateTime?
  lastLoginAt     DateTime?
  auth            UserAuth?
  contactInfo     UserContact?
  sessions        Session[]
  preferences     UserPreference?
  expenses        Expense[]
  categories      Category[]
  provider        String?       // OAuth provider name
  providerAccountId String?     // OAuth provider's user ID
  firstName       String        // Sensitive data - should be encrypted at rest
  lastName        String?       // Sensitive data - should be encrypted at rest
  isDeleted       Boolean       @default(false)
  notifications   NotificationSetting[]
  incomes         Income[]
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  securityLevel   Int          @default(1) // For row-level security policies
  dataRegion      String?      // For data residency compliance

  @@index([email, isDeleted])
  @@index([securityLevel, isDeleted]) // Optimize row-level security queries
  @@map("users")
}

/// UserAuth model with enhanced security features
/// Handles authentication and security-related data
model UserAuth {
  id                    String    @id @default(cuid())
  userId                String    @unique
  password              String    // Sensitive - should be encrypted at rest
  passwordSalt          String    // Sensitive - should be encrypted at rest
  passwordResetToken    String?   // Sensitive - should be encrypted at rest
  passwordResetExpires  DateTime?
  failedLoginAttempts   Int       @default(0)
  lastFailedLoginAt     DateTime?
  lockedUntil           DateTime?
  passwordHashVersion   Int       @default(1)
  mfaEnabled           Boolean    @default(false)
  mfaSecret            String?    // Sensitive - should be encrypted at rest
  backupCodes          String[]   @default([]) // Sensitive - should be encrypted at rest
  lastPasswordChange   DateTime   @default(now())
  isDeleted           Boolean     @default(false)
  user                User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  securityAuditLog    Json?      // Store security-related events

  @@index([passwordResetToken]) // Optimize password reset lookups
  @@index([userId, isDeleted])  // Optimize user auth lookups with soft delete
  @@map("user_auth")
}

/// UserContact model with sensitive data handling
model UserContact {
  id        String    @id @default(cuid())
  userId    String    @unique
  firstName String    // Sensitive - should be encrypted at rest
  lastName  String?   // Sensitive - should be encrypted at rest
  phone     String?   @unique // Sensitive - should be encrypted at rest
  avatarUrl String?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now())
  encryptionStatus DataEncryptionStatus @default(ENCRYPTED)

  @@map("user_contacts")
}

/// Expense model with partitioning and performance optimizations
/// Implements row-level security and audit logging
model Expense {
  id              String            @id @default(cuid())
  date            DateTime
  description     String            // Sensitive - should be encrypted at rest
  amount          Decimal          @db.Decimal(10,2)
  categoryId      String
  paymentMethodId String
  notes           String?          // Sensitive - should be encrypted at rest
  userId          String
  category        Category          @relation(fields: [categoryId], references: [id])
  paymentMethod   PaymentMethod     @relation(fields: [paymentMethodId], references: [id])
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  receipt         Receipt?
  recurring       RecurringExpense?
  isVoid          Boolean           @default(false)
  voidReason      String?           // Sensitive - should be encrypted at rest
  originalAmount  Decimal?          @db.Decimal(10,2)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  partitionKey    String           @default(dbgenerated("TO_CHAR(date, 'YYYY_MM')")) // For table partitioning
  auditLog        Json?            // Track changes
  securityLevel   Int              @default(1)

  // Composite indexes for common query patterns
  @@index([userId, date, isVoid, securityLevel]) // Optimize filtered queries
  @@index([categoryId, date])     // Optimize category-based reporting
  @@index([userId, partitionKey]) // Optimize partitioned queries
  @@index([paymentMethodId, date]) // Optimize payment method analytics

  // Partition by date range
  @@index([partitionKey])
  @@map("expenses")
}

/// Income model with partitioning and performance optimizations
model Income {
  id              String            @id @default(cuid())
  date            DateTime
  description     String            // Sensitive - should be encrypted at rest
  amount          Decimal          @db.Decimal(10,2)
  categoryId      String
  paymentMethodId String
  notes           String?          // Sensitive - should be encrypted at rest
  userId          String
  category        Category          @relation(fields: [categoryId], references: [id])
  paymentMethod   PaymentMethod     @relation(fields: [paymentMethodId], references: [id])
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  recurring       RecurringIncome?
  isVoid          Boolean           @default(false)
  voidReason      String?           // Sensitive - should be encrypted at rest
  originalAmount  Decimal?          @db.Decimal(10,2)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  partitionKey    String           @default(dbgenerated("TO_CHAR(date, 'YYYY_MM')"))
  auditLog        Json?
  securityLevel   Int              @default(1)

  // Composite indexes for common query patterns
  @@index([userId, date, isVoid, securityLevel])
  @@index([categoryId, date])
  @@index([userId, partitionKey])
  @@index([paymentMethodId, date])

  // Partition by date range
  @@index([partitionKey])
  @@map("incomes")
}

/// RecurringIncome model for handling recurring income patterns
model RecurringIncome {
  id              String           @id @default(cuid())
  incomeId        String          @unique
  patternId       String
  startDate       DateTime
  endDate         DateTime?
  lastProcessed   DateTime
  nextProcessDate DateTime
  pattern         RecurringPattern @relation(fields: [patternId], references: [id])
  income          Income          @relation(fields: [incomeId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @default(now())

  @@index([nextProcessDate])
  @@map("recurring_incomes")
}

model NotificationSetting {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  enabled   Boolean         @default(true)
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @default(now())

  @@unique([userId, type])
  @@map("notification_settings")
}

model Currency {
  id           String           @id @default(cuid())
  code         String           @unique // USD, EUR, etc.
  symbol       String           // $, â‚¬, etc.
  name         String
  preferences  UserPreference[]
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  @@map("currencies")
}

model Language {
  id           String           @id @default(cuid())
  code         String           @unique // en, es, etc.
  name         String
  preferences  UserPreference[]
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @default(now())

  @@map("languages")
}

model Theme {
  id           String           @id @default(cuid())
  name         String           @unique // light, dark
  preferences  UserPreference[]
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @default(now())

  @@map("themes")
}

model PaymentMethod {
  id        String            @id @default(cuid())
  name      PaymentMethodEnum @unique
  icon      String?
  expenses  Expense[]
  incomes   Income[]         // Add this line
  createdAt DateTime          @default(now())
  updatedAt DateTime          @default(now())

  @@map("payment_methods")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@map("sessions")
}

model CategoryType {
  id          String     @id @default(cuid())
  name        String     @unique
  icon        String?
  categories  Category[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @default(now())

  @@map("category_types")
}

model Category {
  id            String       @id @default(cuid())
  name          String
  typeId        String
  icon          String?
  color         String?
  userId        String
  budget        Float?
  type          CategoryType @relation(fields: [typeId], references: [id])
  user          User         @relation(fields: [userId], references: [id])
  expenses      Expense[]
  incomes       Income[]     // Add this line
  isDefault     Boolean      @default(false)
  isSystem      Boolean      @default(false)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now())

  @@unique([userId, name], name: "userId_name")
  @@index([userId])
  @@index([typeId])
  @@index([userId, isDefault])
  @@map("categories")
}

model RecurringPattern {
  id              String            @id @default(cuid())
  type            RecurringType
  frequency       Int               // every X intervals
  dayOfWeek      Int?              // 0-6 for weekly
  dayOfMonth     Int?              // 1-31 for monthly
  monthOfYear    Int?              // 1-12 for yearly
  expenses       RecurringExpense[]
  incomes        RecurringIncome[]
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@map("recurring_patterns")
}

model RecurringExpense {
  id              String           @id @default(cuid())
  expenseId       String          @unique
  patternId       String
  startDate       DateTime
  endDate         DateTime?
  lastProcessed   DateTime
  nextProcessDate DateTime
  pattern         RecurringPattern @relation(fields: [patternId], references: [id])
  expense         Expense         @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @default(now())

  @@index([nextProcessDate])
  @@map("recurring_expenses")
}

model Receipt {
  id          String   @id @default(cuid())
  expenseId   String   @unique
  fileUrl     String
  fileName    String
  fileSize    Int
  mimeType    String
  expense     Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now())

  @@map("receipts")
}

model UserPreference {
  id           String    @id @default(cuid())
  userId       String    @unique
  currencyId   String
  languageId   String
  themeId      String
  monthlyBudget Float?    @default(0)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  currency     Currency  @relation(fields: [currencyId], references: [id])
  language     Language  @relation(fields: [languageId], references: [id])
  theme        Theme     @relation(fields: [themeId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now())

  @@map("user_preferences")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}